class UnionFind():
    def __init__(self, n):
        self.p = list(range(n))
        self.r = [1] * n
        self.cnt = [1] * n

    def find(self, x):
        if x != self.p[x]:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            # return True

            if self.r[px] < self.r[py]:
                self.p[px] = self.p[py]
                self.cnt[py] += self.cnt[px]
                self.cnt[px] = 0
            elif self.r[px] > self.r[py]:
                self.p[py] = self.p[px]
                self.cnt[px] += self.cnt[py]
                self.cnt[py] = 0
            else:
                self.p[py] = self.p[px]
                self.cnt[px] += self.cnt[py]
                self.cnt[py] = 0
                self.r[px] += 1
        # return False


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        n = len(graph)
        uf = UnionFind(n)
        for i in range(n):
            for j in range(i, n):
                if graph[i][j] == 1:
                    uf.union(i, j)

        count = collections.Counter(uf.find(u) for u in initial)
        ans = (-1, min(initial))
        for node in initial:
            root = uf.find(node)
            if count[root] == 1:  # unique color
                if uf.cnt[root] > ans[0]:
                    ans = uf.cnt[root], node
                elif uf.cnt[root] == ans[0] and node < ans[1]:
                    ans = uf.cnt[root], node

        return ans[1]